"use strict";(globalThis.webpackChunkhumanoid_robot_book=globalThis.webpackChunkhumanoid_robot_book||[]).push([[221],{723:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>f,default:()=>y,frontMatter:()=>p,metadata:()=>i,toc:()=>x});const i=JSON.parse('{"id":"kinematics-dynamics/index","title":"03 - Kinematics and Dynamics","description":"Kinematics and dynamics are fundamental concepts in robotics, crucial for understanding and controlling the movement of humanoid robots. Kinematics describes motion without considering the forces, while dynamics incorporates forces and torques.","source":"@site/docs/03-kinematics-dynamics/index.mdx","sourceDirName":"03-kinematics-dynamics","slug":"/kinematics-dynamics/","permalink":"/humanoid-robot-book/docs/kinematics-dynamics/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"02 - Humanoid Robot Anatomy","permalink":"/humanoid-robot-book/docs/anatomy/"},"next":{"title":"04 - Sensors and Perception","permalink":"/humanoid-robot-book/docs/sensors-perception/"}}');var o=t(4848),a=t(8453),r=t(6540),s=t(6069),c=t.n(s),l=t(1983);t(5624),t(5723),t(2342);const d="editorContainer_obiS",h="executeButton_dezK",u="outputArea_tzjB",m=({initialCode:e=""})=>{const[n,t]=(0,r.useState)(e),[i,a]=(0,r.useState)("");return(0,o.jsxs)("div",{className:d,children:[(0,o.jsx)(c(),{value:n,onValueChange:t,highlight:e=>(0,l.highlight)(e,l.languages.python,"python"),padding:10,style:{fontFamily:"monospace",fontSize:16,backgroundColor:"var(--docusaurus-code-background-color)",color:"var(--docusaurus-code-text-color)",border:"1px solid var(--ifm-color-primary-lightest)",borderRadius:"5px",minHeight:"150px"}}),(0,o.jsx)("button",{onClick:()=>{try{n.includes("print(")?a(`Simulated Output: ${n.match(/print\((.*)\)/)?.[1]||"..."}`):n.includes("def")?a("Simulated: Function defined. (Cannot execute complex Python directly in browser)"):a(`Simulated Output for: \n${n}`)}catch(e){a(`Simulated Error: ${e.message}`)}},className:h,children:"Run Code"}),i&&(0,o.jsx)("pre",{className:u,children:(0,o.jsx)("code",{children:i})})]})},p={},f="03 - Kinematics and Dynamics",g={},x=[{value:"Kinematics: Describing Motion",id:"kinematics-describing-motion",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Try it yourself!",id:"try-it-yourself",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Jacobians",id:"jacobians",level:3},{value:"Dynamics: Forces, Torques, and Motion",id:"dynamics-forces-torques-and-motion",level:2},{value:"Statics",id:"statics",level:3},{value:"Dynamics Equations",id:"dynamics-equations",level:3}];function j(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"03---kinematics-and-dynamics",children:"03 - Kinematics and Dynamics"})}),"\n",(0,o.jsx)(n.p,{children:"Kinematics and dynamics are fundamental concepts in robotics, crucial for understanding and controlling the movement of humanoid robots. Kinematics describes motion without considering the forces, while dynamics incorporates forces and torques."}),"\n",(0,o.jsx)(n.h2,{id:"kinematics-describing-motion",children:"Kinematics: Describing Motion"}),"\n",(0,o.jsx)(n.p,{children:"Kinematics deals with the geometric aspects of robot motion, focusing on the position, velocity, and acceleration of the robot's links and joints."}),"\n",(0,o.jsx)(n.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Forward kinematics (FK)"})," is the process of calculating the position and orientation of the end-effector (e.g., hand, foot) given the joint angles of the robot. For a robot with ",(0,o.jsx)(n.code,{children:"n"})," joints, if we know all ",(0,o.jsx)(n.code,{children:"n"})," joint angles, FK tells us where the end-effector is in 3D space."]}),"\n",(0,o.jsx)(n.p,{children:"Mathematically, FK can be represented by a transformation matrix (e.g., using Denavit-Hartenberg parameters) that maps the joint space to the Cartesian space."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: 2-DOF Planar Arm (Python)"})}),"\n",(0,o.jsxs)(n.p,{children:["Let's consider a simple 2-Degrees of Freedom (DoF) planar arm with two links of lengths ",(0,o.jsx)(n.code,{children:"L1"})," and ",(0,o.jsx)(n.code,{children:"L2"}),". The joint angles are ",(0,o.jsx)(n.code,{children:"theta1"})," and ",(0,o.jsx)(n.code,{children:"theta2"})," (measured from the previous link)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\ndef forward_kinematics_2dof(L1, L2, theta1_deg, theta2_deg):\n    theta1 = np.deg2rad(theta1_deg)\n    theta2 = np.deg2rad(theta2_deg)\n\n    # Joint 1 position (origin)\n    x0, y0 = 0, 0\n\n    # Joint 2 position\n    x1 = L1 * np.cos(theta1)\n    y1 = L1 * np.sin(theta1)\n\n    # End-effector position\n    x2 = x1 + L2 * np.cos(theta1 + theta2)\n    y2 = y1 + L2 * np.sin(theta1 + theta2)\n\n    return (x0, y0), (x1, y1), (x2, y2)\n\n# Parameters\nL1 = 1.0  # length of first link\nL2 = 0.8  # length of second link\ntheta1_deg = 30 # degrees\ntheta2_deg = 60 # degrees\n\n# Calculate FK\njoint0, joint1, end_effector = forward_kinematics_2dof(L1, L2, theta1_deg, theta2_deg)\n\nprint(f\"Joint 0: {joint0}\")\nprint(f\"Joint 1: {joint1}\")\nprint(f\"End-effector: {end_effector}\")\n\n# Plotting (requires matplotlib)\nplt.figure(figsize=(6, 6))\nplt.plot([joint0[0], joint1[0]], [joint0[1], joint1[1]], 'ro-', linewidth=2, label='Link 1')\nplt.plot([joint1[0], end_effector[0]], [joint1[1], end_effector[1]], 'go-', linewidth=2, label='Link 2')\nplt.plot(end_effector[0], end_effector[1], 'bx', markersize=10, label='End-effector')\n\nplt.xlim(-L1 - L2, L1 + L2)\nplt.ylim(-L1 - L2, L1 + L2)\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.title('2-DoF Planar Arm Forward Kinematics')\nplt.grid(True)\nplt.legend()\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"try-it-yourself",children:"Try it yourself!"}),"\n",(0,o.jsx)(m,{initialCode:'L1 = 1.0\nL2 = 0.8\ntheta1_deg = 45 # degrees\ntheta2_deg = 90 # degrees\n\n# Call the function (assume forward_kinematics_2dof is defined elsewhere or paste it in)\n# x0, y0, x1, y1, x2, y2 = forward_kinematics_2dof(L1, L2, theta1_deg, theta2_deg)\nprint(f"Hello from the live editor!")\nprint(f"Input angles: {theta1_deg}, {theta2_deg}")'}),"\n",(0,o.jsx)(n.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Inverse kinematics (IK)"})," is the opposite problem: given a desired position and orientation of the end-effector, calculate the joint angles required to achieve that pose. IK is significantly more complex than FK, often having multiple solutions (redundancy), no solutions (reachability limits), or singularities."]}),"\n",(0,o.jsx)(n.p,{children:"IK is crucial for task-oriented control, where a robot needs to reach a specific point in space. Solutions often involve iterative numerical methods or analytical solutions for simpler robots."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: 2-DOF Planar Arm IK (Analytical - Python)"})}),"\n",(0,o.jsx)(n.p,{children:"For a 2-DoF planar arm, an analytical solution exists."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef inverse_kinematics_2dof(L1, L2, target_x, target_y):\n    # Calculate distance from origin to target\n    D_squared = target_x**2 + target_y**2\n    D = np.sqrt(D_squared)\n\n    # Check if target is reachable\n    if D > (L1 + L2) or D < abs(L1 - L2):\n        print("Target out of reach.")\n        return None, None\n\n    # Calculate theta2 (using law of cosines)\n    cos_theta2 = (D_squared - L1**2 - L2**2) / (2 * L1 * L2)\n    if abs(cos_theta2) > 1:\n        print("Calculation error for theta2. Adjust target or link lengths.")\n        return None, None\n    theta2 = np.arctan2(np.sqrt(1 - cos_theta2**2), cos_theta2) # Elbow up solution\n    # Alternative: elbow down solution: theta2 = np.arctan2(-np.sqrt(1 - cos_theta2**2), cos_theta2)\n\n    # Calculate theta1\n    alpha = np.arctan2(target_y, target_x)\n    beta = np.arctan2(L2 * np.sin(theta2), L1 + L2 * np.cos(theta2))\n    theta1 = alpha - beta\n\n    return np.rad2deg(theta1), np.rad2deg(theta2)\n\n# Parameters\nL1 = 1.0\nL2 = 0.8\ntarget_x = 1.5\ntarget_y = 0.5\n\n# Calculate IK\ntheta1_ik, theta2_ik = inverse_kinematics_2dof(L1, L2, target_x, target_y)\n\nif theta1_ik is not None and theta2_ik is not None:\n    print(f"Target ({target_x}, {target_y})")\n    print(f"Calculated Joint Angles: theta1 = {theta1_ik:.2f} degrees, theta2 = {theta2_ik:.2f} degrees")\n\n    # Verify with FK\n    _, _, fk_end_effector = forward_kinematics_2dof(L1, L2, theta1_ik, theta2_ik)\n    print(f"FK verification end-effector: ({fk_end_effector[0]:.2f}, {fk_end_effector[1]:.2f})")\n'})}),"\n",(0,o.jsx)(n.h3,{id:"jacobians",children:"Jacobians"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"Jacobian matrix"})," is a fundamental tool in robotics that relates joint velocities to end-effector velocities (both linear and angular). It is the partial derivative of the forward kinematics equations with respect to each joint variable."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"v_e = J * dot_q"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"v_e"}),": End-effector velocity (linear and angular)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"J"}),": Jacobian matrix"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dot_q"}),": Joint velocities"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The Jacobian is essential for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Velocity Control:"})," Directly mapping desired end-effector velocities to required joint velocities."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularity Analysis:"})," Points where the Jacobian loses rank (determinant is zero) are called singularities, representing configurations where the robot loses one or more DoF and cannot move its end-effector in certain directions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Force Mapping:"})," The transpose of the Jacobian maps forces/torques from the end-effector to the joints (",(0,o.jsx)(n.code,{children:"tau = J^T * F_e"}),")."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"dynamics-forces-torques-and-motion",children:"Dynamics: Forces, Torques, and Motion"}),"\n",(0,o.jsx)(n.p,{children:"Dynamics deals with the study of motion considering the forces and torques that cause it. This is crucial for controlling the robot's acceleration, handling disturbances, and understanding energy consumption."}),"\n",(0,o.jsx)(n.h3,{id:"statics",children:"Statics"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Statics"})," is a special case of dynamics where the robot is in equilibrium (no acceleration). It focuses on the forces and torques required to hold a robot in a specific pose or to move it very slowly."]}),"\n",(0,o.jsx)(n.p,{children:"For a robot in static equilibrium, the sum of all forces and torques acting on each link is zero. This is particularly important for humanoid robots in standing or quasi-static walking phases."}),"\n",(0,o.jsx)(n.h3,{id:"dynamics-equations",children:"Dynamics Equations"}),"\n",(0,o.jsx)(n.p,{children:"The full dynamic equations of motion for a robot are often complex and non-linear. They typically take the form:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"M(q) * dot_dot_q + C(q, dot_q) * dot_q + G(q) = tau"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"q"}),": Joint angles vector"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dot_q"}),": Joint velocities vector"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dot_dot_q"}),": Joint accelerations vector"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"M(q)"}),": Mass (or inertia) matrix, which depends on the joint configuration."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"C(q, dot_q)"}),": Coriolis and centrifugal forces matrix."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"G(q)"}),": Gravity vector, dependent on joint configuration."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tau"}),": Joint torques generated by actuators."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Solving or simulating these equations allows engineers to predict how a robot will move under specific torques or to calculate the torques required for desired movements. This is fundamental for advanced control strategies like impedance control and model predictive control."}),"\n",(0,o.jsx)(n.p,{children:"Understanding both kinematics and dynamics provides the theoretical foundation for designing, simulating, and controlling the complex movements of humanoid robots."})]})}function y(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(j,{...e})}):j(e)}}}]);